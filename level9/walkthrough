1)	first impressions :
		-some strange functions
			-_Znwj@plt
			-_ZN1NC2Ei
			-_ZN1N13setAnnotationEPc
		-some libc functions (memcpy, strlen, exit)
		-N::N functions

2)	_Znwj allocates memory with malloc.
	_ZN1NC2Ei put function address inside _Znwj allocated buf
		=> function : 0x8048848 <_ZTV1N+8>:	0x804873a <_ZN1NplERS_>

3)	We have two pointers declared on stack : ptr1 and ptr2
	They will be set with addresses on the heap (result of _Znwj function which allocates heap memory and returns the pointer)
	Then function _ZN1NC2Ei fills those 2 buffers with :
		-an address on the 4 first bytes
		-int values 5 or 6 on the last 4 bytes
	_ZN1N13setAnnotationEPc function copies (without controlling the size), argv1 into ptr1 + 4
		=> As ptr2 heap addresses are just after ptr1 heap addresses, we can overflow on them via this memcpy
	Then, further in the main, ptr2 first 4 bytes are dereferenced, which result in the address stored in the 4 first bytes of ptr2
		=> This address is dereferenced again, (should go into some lib.)
			=> What we did is : as we control ptr2 first 4 bytes via memcpy of argv1 into ptr1, we put an address at ptr1 + 4
				=> This address at ptr1 + 4 points to ptr2 + 4 (which contains our shellcode)

outside vm :
0x804ebb0 == start buf1 == 0x08048848
0x804ec1c == 5 (end of malloced buff)
0x804ec20 == start buf2 == 0x08048848
0x804ec88 == 6 (end buf2)

inside vm :
buf1 == 0x804a008
buf2 == 0x804a078

3)	overflow memcpy with argv1 to override buf2 with syscall ?
