1)	first impressions :
		-main with malloc functions + strcpy
		-n function : success function, cats pass file
		-m function : failure function, prints nope

2)	When ran with a string



&buf1 = 0x804a1a0
&buf2 = 0x804a1f0

esp + 24 = 0x0804a1f0 == buf2 ?

ebp + 12 = 0xffffcf54 == argv0
ebp + 16 = 0xffffcf58 == argv1

0xffffd164 : argv1 string in data section

We see that the address of m is saved in buf2.
Printing heap from buf1 addr, we see that buf2 is 72 bytes further in the addresses.
As strcpy does not copy a given number of characters, we did a heap overflow to write address of n at buf2 heap memory location.
	=> argv1 is copied to buf1 which overflows into buf2
