1)	first impressions
		-functions	
			-main
			-p		0x080484b4
			-pp		0x0804851e
			-strcpy, strcat, strchr, read, puts, strncpy
		-behavior
			=> reads for 2 separate inputs on stdin, then prints them on stdout
			=> large input = segfault (some overflow)
	

2)	inside 


dest1 == 0xffffce38 
dest2 == 0xffffce4c

arg0 strcpy pp == 0xffffce86
	=> stores the two strings we read

ebp + 8 == 0xffffce70
	=> value == 0xffffce86 == start buf pp

main sEIP = 0xffffcebc


We saw that 2 read of 4096 bytes are performed on STDIN. First challenge was to see how to read two times.
We filled stdin with :
	=> 20bytes of shellcode (start) + 4075 bytes of padding + 1 \n  ==> 20 first bytes fill BUF1 (strncpy blocks maximum 20 bytes)
	=> 5bytes of shellcode (end) + 9 bytes of padding + address of BUF1 (shellcode)

We were forced to have 4075 useless bytes because we needed the read to end with a \n (entry key on a classic user input)
As BUF1 and BUF2 are contiguous on the stack, our shellcode (which is given in two parts) is "reunited" and can be executed